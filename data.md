# 模型输出结果

## 数据情况
1. process.py 原始数据预处理
````
数据输入：读取.dat二进制文件，原始数据格式为int32
通道分离：将交错排列的I/Q样本分离为独立数组
符号转换：将16位有符号数从无符号存储格式转换为实际有符号值（处理二进制补码）
复数构造：将I/Q两路实数信号组合为复数信号（I + jQ）
帧处理：
默认期望每帧1056*75个样本，共50帧
自动处理数据长度异常（不足时减少帧数，过长时截断）
输出存储：将处理后的复数数组保存为.npy格式，保留原始文件名
````
2. datasets.py 数据集划分
参数normalize_way：不同的归一化方式minmax: 最小-最大归一化, zscore: Z-Score标准化 
### random（随机数据集）
- **对应类**：`SiameseIQDataset_random`
- **特点**：
  - 50%概率生成正样本对（同类别），50%生成负样本对（不同类别）
  - 正样本从同文件随机选取
  - 负样本从其他文件随机选取

### balanced_1（均衡数据集1）
- **对应类**：`SiameseIQDataset_balanced_1`
- **特点**：
  - 维护所有可能的类别对(pairs)
  - 使用计数器记录每个类别对的使用次数
  - 优先选择使用次数最少的类别对生成负样本

### balanced_2（均衡数据集2）
- **对应类**：`SiameseIQDataset_balanced_2` 
- **特点**：
  - 预生成所有可能的负样本类别对
  - 使用循环方式遍历所有负样本对
  - 确保每个负样本对都被均匀使用

### triplet（三元组数据集）
- **对应类**：`TripletIQDataset`
- **特点**：
  - 生成三元组数据（anchor, positive, negative）
  - 维护类别索引映射表
  - 使用计数器平衡不同类别对的使用次数
  - 每个样本返回`(anchor, positive, negative)`三个样本

### simple（简单数据集）
- **对应类**：基础`IQDataset`
- **特点**：
  - 直接返回单个样本和标签
  - 用于普通分类任务而非metric learning
  - 生成原始IQ数据样本，不构造样本对

3. 加载数据集 trainer.py
````
数据文件统计: 共40个类别，总样本数30532
每个类别的帧数: 类别0: 191, 类别1: 191, 类别2: 191, 类别3: 191, 类别4: 191, 类别5: 191, 类别6: 191, 类别7: 191, 类别8: 191, 类别9: 191, 类别10: 191, 类别11: 191, 类别12: 191, 类别13: 191, 类别14: 191, 类别15: 191, 类别16: 191, 类别17: 191, 类别18: 191, 类别19: 191, 类别20: 191, 类别21: 191, 类别22: 191, 类别23: 191, 类别24: 191, 类别25: 191, 类别26: 191, 类别27: 191, 类别28: 191, 类别29: 191, 类别30: 184, 类别31: 191, 类别32: 191, 类别33: 191, 类别34: 191, 类别35: 191, 类别36: 191, 类别37: 191, 类别38: 191, 类别39: 191
加载已有的训练集/验证集划分，训练集: 24417，验证集: 6115
````
4. 训练 trainer.py
从嵌入向量可视化图和Nearest Neighbor Accuracy、Intra-class Distance vs Inter-class Distance这两个指标评估模型
同时输出训练中loss变化图（traning_loss_curves.png）
5. 微调（分类器） fine_tune.py
参数classifier：不同的分类器fc: 全连接分类器, mlp_resnet: MLPResNet分类器（MLPResNetClassifier）
输出混淆矩阵以及分类器模型
同时输出微调中loss和准确率变化图（traning_curves.png）
6. 测试 testnew.py
输出准确率 精确率 召回率 F1值等信息